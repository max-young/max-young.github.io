---
layout:     post
title:      "Docker相关知识"
date:       2022-11-13
categories: Docker
tags:
    - Docker
---

- [初印象](#初印象)
  - [安装](#安装)
  - [参考资料](#参考资料)
  - [DEMO](#demo)
- [相关知识](#相关知识)
  - [基本命令](#基本命令)
  - [创建自定义镜像](#创建自定义镜像)
    - [Dockerfile](#dockerfile)
      - [基本格式](#基本格式)
      - [Parser directives](#parser-directives)
      - [Environment replacement](#environment-replacement)
      - [.dockerignore file](#dockerignore-file)
      - [FROM](#from)
      - [RUN](#run)
      - [CMD和ENTRYPOINT的区别](#cmd和entrypoint的区别)
      - [LABEL](#label)
      - [MAINTAINER](#maintainer)
      - [EXPOSE](#expose)
      - [ENV](#env)
      - [ADD 和 COPY](#add-和-copy)
      - [VOLUME](#volume)
      - [USER](#user)
      - [WORKDIR](#workdir)
  - [使用Docker构建服务](#使用docker构建服务)
  - [Docker编配](#docker编配)
    - [Docker Compose](#docker-compose)
      - [简单的例子](#简单的例子)
      - [docker-compose的基本命令](#docker-compose的基本命令)

# Docker学习笔记

## 初印象

### 安装

https://docs.docker.com/docker-for-mac/install/#install-and-run-docker-for-mac  

### 参考资料  

官方文档  

[第一本Docker书](https://book.douban.com/subject/26285268/)

### DEMO  

- Django应用  

    1. demo  
        <https://docs.docker.com/compose/django/#create-a-django-project>  
    2. PostgreSQL  
        <https://hub.docker.com/_/postgres/>
    3. 在docker里面启动终端运行相关命令  
        How do you perform Django database migrations when using Docker-Compose?
        ```shell
        # 先启动Django应用，可用-d来守护进程启动
        $ docker-compose up
        # 查询到django的container id
        $ docker ps
        # 启动bash
        $ docker exec -i -t 9ff9184c2182 bash
        ```
    4. 连接PostgreSQL  
        ```shell
        $ psql -h postgres -U clm
        ```
        host默认是postgres  
        username和password看docker-compose.yml里面的配置  
        如果没有安装psql，则通过`apt-get install postgresql-client`来安装  

## 相关知识

### 基本命令

- 启动一个容器  
  
    举例如下： 
    ```shell
    # 以centos镜像启动一个容器
    $ docker run --name my_container -it centos
    ```
    `--name`参数可以为容器命名，也可以不加此参数，命名必需唯一
    `it`参数可以理解为进入命令行界面，如果本地没有centos镜像则会从官方镜像里下载，命令后面还可以加进入容器后的命令，比如`/bin/bash`，`ls`等等，看看效果吧    
    
- 查看容器  

    ```shell
    # 查看运行中的容器  
    $ docker ps  
    # 查看所有容器  
    $ docker ps -a
    ```
  可以查看到容器的信息，比如id，名称，等等   
  
- 重新启动一个容器  

    ```shell
    $ docker restart my_container
    ```
  后面可以加容器的名称，或者容器的id  
  
- 附着到容器上  

  以上面的centos容器为例，`docker start`重新启动之后，是守护进程启动，如果我们要进入命令行，可以用附着命令： 
    ```shell
    # 可以使容器名称也可以是id
    $ docker attach my_container
    ```
  进入命令行之后exit，容器也会关闭  
  这里只适用于centos、ubuntu这种linux镜像  
  如果我们用`docker exec -it my_container bash`进入命令行，exit后容器不会关闭，下面会讲到  
  
- 查看日志  

  守护进程启动Django应用，我们可以用下面的命令来查看日志  
    ```shell
    # 后面可加上容器名称或者id
    $ docker logs my_container
    # 查看日志实时更新
    $ docker logs -f my_container
    ```
- 查看容器内的进程  
    
    `$ docker top my_container`
    
- 查看容器的统计信息 

    `$ docker stats my_container1 my_container2`
    
- 在容器内运行进程  

  用docker exec来实现  
  - 在容器内运行后台任务  
    `$ docker exec -d my_container touch /etc/new_file`
  - 在容器内运行交互命令  
    `$ docker exec -it my_container bash`  

- 停止守护容器  
    
    `$ docker stop my_container`  

- 查看容器的详细信息  

    `$ docker inspect my_container`  
    
- 删除容器  

    `$ docker rm my_container`

- 容器和主机之间复制文件  

  `$ docker cp <containerId>:/file/path/within/container /host/path/target`

---

### 创建自定义镜像

镜像可以从官方获取，比如我们以centos镜像启动一个仓库，命令是：  

```shell
$ docker run -it centos bash
```

docker会先看本地有没有docker镜像，如果没有则从官方获取centos:latest镜像

可以指定centos的版本，不指定的话默认latest  

进入bash之后是一个空的centos系统，可以通过`yum install vim`来安装vim  

我们不想每次都安装vim，可不可以将安装vim后的仓库生成一个自定义的镜像呢，这样下次就不用安装vim了  

这就是自定义镜像的由来，创建自定义镜像的方式有两种，一种是commit，一种是Dockerfile, 不推荐commit这种方法，具体使用参照文档  
   
#### Dockerfile  

用Dockerfile的方式创建镜像，基本的命令是：  

```shell
$ docker build -t max/test .
```

`-t`是指定镜像的仓库和名称，之后是指定Dockerfile的路径，这里假定Dockerfile是在当前路径  

所以用Dockerfile的方式创建镜像的步骤是：  
```shell
# 创建一个存放Dockerfile的路径
$ mkdir test && cd test
# 创建一个Dockerfile文件
$ vim Dockerfile
# 创建镜像
$ docker build -t max/test .
```
Dockerfile的内容和规范参照文档<https://docs.docker.com/engine/reference/builder/>  

另外, 强烈推荐这个实操文档<https://docs.docker.com/develop/develop-images/dockerfile_best-practices/>

格式说明:  

##### 基本格式

```dockerfile
# Comment
INSTRUCTION arguments
```
`#`代表注释  
instruction可以大小写, 但是为了与arguments区分, 最好是大写  
FROM是必须的, 代表从哪个基本镜像开始构建

##### Parser directives

这个代表如何解析命令, 这个是可选的, 需要在文件的最上面标注, 现在支持两种: syntax和escape  
syntax指定dockfile的镜像版本, 一般用不上  
escape有的时候能用到, 例如默认的escape是右下划线\, 我们在Dockfile里写入:
```dockerfile
FROM microsoft/nanoserver
COPY testfile.txt c:\\
RUN dir c:\
```
因为默认的escape是\\, 所以执行时会报错: 
```shell
PS C:\John> docker build -t cmd .
Sending build context to Docker daemon 3.072 kB
Step 1/2 : FROM microsoft/nanoserver
 ---> 22738ff49c6d
Step 2/2 : COPY testfile.txt c:\RUN dir c:
GetFileAttributesEx c:RUN: The system cannot find the file specified.
PS C:\John>
```
如果我们首行记上自定义escape的parser directive注释, 则会避免这个问题
```dockerfile
# escape=`

FROM microsoft/nanoserver
COPY testfile.txt c:\
RUN dir c:\
```
运行结果是:
```shell
PS C:\John> docker build -t succeeds --no-cache=true .
Sending build context to Docker daemon 3.072 kB
Step 1/3 : FROM microsoft/nanoserver
 ---> 22738ff49c6d
Step 2/3 : COPY testfile.txt c:\
 ---> 96655de338de
Removing intermediate container 4db9acbb1682
Step 3/3 : RUN dir c:\
 ---> Running in a2c157f842f5
 Volume in drive C has no label.
 Volume Serial Number is 7E6D-E0F7

 Directory of c:\

10/05/2016  05:04 PM             1,894 License.txt
10/05/2016  02:22 PM    <DIR>          Program Files
10/05/2016  02:14 PM    <DIR>          Program Files (x86)
10/28/2016  11:18 AM                62 testfile.txt
10/28/2016  11:20 AM    <DIR>          Users
10/28/2016  11:20 AM    <DIR>          Windows
           2 File(s)          1,956 bytes
           4 Dir(s)  21,259,096,064 bytes free
 ---> 01c7f3bef04f
Removing intermediate container a2c157f842f5
Successfully built 01c7f3bef04f
PS C:\John>
```
##### Environment replacement
环境变量替换, 基本用法:
```shell
FROM busybox
ENV foo /bar
WORKDIR ${foo}   # WORKDIR /bar
ADD . $foo       # ADD . /bar
COPY \$foo /quux # COPY $foo /quux
```
上面定义了foo这个环境变量的值`/bar`, 在下面就可以使用了, 两种用法`${foo}`和`$foo`都可以, 但是加上escape则失效了, 环境变量在下面这些instruction里可以使用:
- ADD
- COPY
- ENV
- EXPOSE
- FROM
- LABEL
- STOPSIGNAL
- USER
- VOLUME
- WORKDIR
如果我们重复定义了同一个环境变量会怎么样呢:
```shell
ENV abc=hello
ENV abc=bye def=$abc
ENV ghi=$abc
```
def的值会是hello, ghi的值会是bye
##### .dockerignore file
在Dockerfile在一个路径下可以定义`.dockerignore`这个文件, 这个文件可以使`ADD`和`COPY`时忽略这个文件里面的内容, `.dockerignore`的内容格式如下:
```shell
# comment
*/temp*
*/*/temp*
temp?
```
##### FROM

是基础镜像, 必需配置, 使用示例:
```shell
ARG  CODE_VERSION=latest
FROM base:${CODE_VERSION}
CMD  /code/run-app

FROM extras:${CODE_VERSION}
CMD  /code/run-extras
```
在FROM前面可以配置ARG指定镜像版本, 如果没有版本, 则默认latest

##### RUN

在基础镜像上执行命令, 用于之后的操作, 示例:
```shell
RUN <command>
RUN ["executable", "param1", "param2"]
```

##### CMD和ENTRYPOINT的区别    

Dockerfile里只能有一个CMD，如果有多个，则执行最后一个CMD,  
CMD的主要作用是运行容器时的默认命令, docker run会执行CMD，比如Dockerfile里有下面的指令：  
```shell
CMD [ "/bin/bash" ]
```
运行`docker run -i -t max/test`时，就执行了CMD指令进入了bash  
但是如果我们在run里加入命令，比如`docker run -i -t max/test /bin/ps`,则`ps`命令会覆盖掉`bash`命令，不会进入bash

CMD有三种格式:  
- CMD ["executable","param1","param2"] (exec form, this is the preferred form)
- CMD ["param1","param2"] (as default parameters to ENTRYPOINT)
- CMD command param1 param2 (shell form)

如果是第二种作为ENTRYPOINT的参数, 则都需要是这种格式  
如果是第一种, 注意需要是双引号
第三种shell form模式默认是在`/bin/sh -c`下执行(sh是默认的shell), array form是推荐的写法

如果想每次运行容器时都运行同一个命令, 推荐使用Entrypoint + CMD的方式

我们再来说ENTRYPOINT  
我们举一个同时使用ENTRYPOINT和CMD的例子，Dockerfile包含下面的内容：  
```docker
ENTRYPOINT [ "/usr/sbin/nginx" ]
CMD [ "-h" ]
```
docker run里可以为ENTRYPOINT的指令加参数，比如我们运行：  
```shell
$ docker run -t -i max/test -g "daemon off;"
```  
则会把后面的参数`-g "daemon off";`加到ENTRYPOINT的指令`/usr/sbin/nginx`后面  
如果没有加参数，则会把CMD里的参数`-h`加到ENTRYPOINT的指令后面  

官方文档很好的解释了`CMD`和`ENTRYPOINT`的区别:
`CMD`和`ENTYYPOINT`都可以定义启动容器室执行的命令. 两者之间会遵循一些规则:
1. Dockerfile至少定义两者其中的一个
2. ENTRYPOINT should be defined when using the container as an executable.(这个我没理解)
3. `CMD`可作为`ENTRYPOINT`执行的参数
4. `CMD`在运行容器附加参数时被覆盖掉

当两者结合时的运行规则是这样的:

| No ENTRYPOINT	| ENTRYPOINT | exec_entry p1_entry	| ENTRYPOINT [“exec_entry”, “p1_entry”]
 --- | --- | --- |--- | ---
No CMD	| error, not allowed	| /bin/sh -c exec_entry p1_entry	| exec_entry p1_entry
CMD [“exec_cmd”, “p1_cmd”]	| exec_cmd p1_cmd	| /bin/sh -c exec_entry p1_entry	| exec_entry p1_entry exec_cmd p1_cmd
CMD [“p1_cmd”, “p2_cmd”]	| p1_cmd p2_cmd	| /bin/sh -c exec_entry p1_entry	| exec_entry p1_entry p1_cmd p2_cmd
CMD exec_cmd p1_cmd	| /bin/sh -c exec_cmd p1_cmd	| /bin/sh -c exec_entry p1_entry	| exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd

##### LABEL
给镜像加元数据, 也就是属性, 例如:
```shell
LABEL "com.example.vendor"="ACME Incorporated"
LABEL com.example.label-with-value="foo"
LABEL version="1.0"
LABEL description="This text illustrates \
that label-values can span multiple lines."
```
可以通过`docker inspect`来查看

##### MAINTAINER
镜像拥有者创建者, 这个已过期, 可用label替代, 例如:
```shell
LABEL maintainer="SvenDowideit@home.org.au"
```

##### EXPOSE

定义端口去公开, 默认是TCP协议, 也可自定义UDP

##### ENV

环境变量, 两种方式
```docker
ENV key value
ENV key1=value1 key2=value2
```
可以通过`docker inspect`来查看, `docker run --env     key=value`能够改变环境变量

##### ADD 和 COPY

`ADD`和`COPY`功能类似, 都是讲文件添加到容器中, 官方更推荐`COPY`. `COPY`更简单易懂. `ADD`支持一些别的功能, 比如压缩文件添加到容器中时会自动解压缩, 还支持URL(其实这个功能可以用`RUN curl`来解决)

##### VOLUME

新加卷, 可以存放数据文件, 新加卷的内容会存放到host机器上, 用`docker inspect`能查看到位置, 删除容器不会删除volume在host机器上的文件. `RUN mkdir`这个就不行, 删除容器之后这个路径文件也会没了

##### USER

创建用户和用户组
```docker
USER <user>[:<group>] or
USER <UID>[:<GID>]
```
不指定的话默认root

##### WORKDIR

`WORKDIR`指定了`RUN`, `CMD`, `ENTRYPOINT`, `COPY`, `ADD`执行的路径, 用法示例:
```shell
WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
```
结果会是`/a/b/c`  
在`WORKDIR`里也可使用环境变量  
```
ENV DIRPATH /path
WORKDIR $DIRPATH/$DIRNAME
RUN pwd
```
结果会是`/path/$DIRNAME`
        
### 使用Docker构建服务

- 构建Flask web应用  

    <http://containertutorials.com/docker-compose/flask-simple-app.html>  
    
- 构建Redis集群  

    参照[《第一本Docker书》](https://book.douban.com/subject/26285268/)里面的例子  
    
### Docker编配  

编配（orchestration）是一个没有严格定义的概念。这个概念大概描述了自动配置、协作和管理服务的过程。在Docker的世界里，编配用来描述一组实践过程，这个过程会管理运行多个Docker容器内的应用，而这些Docker容器有可能运行在多个宿主机上。

#### Docker Compose  

使用Docker Compose，可以用一个YAML文件定义一组要启动的容器，以及运行时的属性，使这些容器能够交互。  
##### 简单的例子  
下面是一个Flask web应用和Redis结合的例子：  

1. 当前的工作路径是`/composeapp`  
此路径下新建一个Flask应用的app.py文件，代码如下所示：  
    ```Python
    from flask import Flask
    from redis import Redis
    
    app = Flask(__name__)
    redis = Redis(host="redis_1", port=6379)
    
    
    @app.route('/')
    def hello():
        redis.incr('hits')
        return 'Hello Docker Book reader!I have been seen {} times'.format(
            redis.get('hits'))
    
    
    if __name__ == '__main__':
        app.run(host='0.0.0.0', debug=True)
    ```
    可以打看到代码里web应用需要连接Redis，刷新一次主页，计数增加一次  
    那么我们应该怎么办呢，单独启动两个容器，一个Flask容器，一个Redis，然后连接起来？手动来做好像太麻烦了，而且中间不知道会遇到什么问题，这个时候就该docker-compose登场了  
2. 继续新建依赖包文件requirements.txt  
    ```txt
    flask
    redis
    ```
3. 新建Dockerfile用来构建基础镜像，内容如下：
    ```dockerfile
    FROM python:2.7
    MAINTAINER max "18601036905@163.com"
    ADD . /composeapp
    WORKDIR /composeapp
    RUN pip install -r requirements.txt
    ```
    基础镜像是Python，然后将代码路径加入到镜像里，并安装相关依赖包  
4. 创建镜像  
    ```shell
    $ docker build -t max/composeapp .
    ```
5. 创建docker-compose的yaml文件docker-compose.yml 
    内容如下：  
    ```yaml
    web:
      image: max/composeapp1
      command: python app.py
      ports:
        - "5000:5000"
      volumes:
        - .:composeapp1
      links:
        - redis
    redis:
      image: redis
    ```
    定义了两个要启动的服务，web服务里各项含义是镜像、命令、端口、卷、连接其他服务
6. 启动服务  
    ```shell
    $ docker-compose up
    ```
    
##### docker-compose的基本命令  
- 启动  
    `docker-compose up`  
    可以加`-d`后台启动
- 查看进程  
    `docker-compose ps`  
- 查看日志  
    `docker-compose logs`  
    可以加`-f`实时查看  
- 停止服务  
    `docker-compose stop`  